#ifndef __LOG_DUAL_D_H
#define __LOG_DUAL_D_H
#include"ENC.h"

unsigned char const SBOX_INV_G[16][16]={	{0xe3,0xf0,0xec,0xcc,0xde,0x0e,0x25,0x54,0x7a,0x2f,0xe4,0x3b,0x93,0x62,0x3e,0x1e},
											{0x53,0x76,0x1f,0x9a,0xd9,0x10,0x85,0x98,0x33,0xb2,0x58,0x6b,0xba,0x0c,0xa1,0x6d},
											{0x44,0x8d,0xbf,0x5b,0x96,0x39,0x90,0x59,0xc7,0xae,0x01,0x3d,0xeb,0xf8,0x8b,0x81},
											{0x42,0x4f,0xf9,0x7d,0xa8,0xc9,0x38,0x0a,0x99,0x34,0x5c,0x26,0xc1,0x8e,0x13,0x16},
											{0xe1,0x7b,0xab,0xbe,0x73,0x06,0x1a,0xdc,0x82,0xa2,0xc0,0x05,0x31,0xed,0x7c,0x56},
											{0x9e,0x30,0x8f,0x0b,0x02,0x27,0xaa,0xf6,0x5a,0x79,0x5e,0x55,0x36,0x0d,0xdd,0x63},
											{0x03,0xf2,0x72,0x09,0x1b,0x8c,0x60,0xac,0x1d,0x11,0xdb,0x2b,0x5d,0x9c,0x7e,0xd3},
											{0x78,0x67,0x20,0xfd,0x8a,0x21,0x57,0x6f,0x4c,0xca,0x1c,0x04,0xb0,0x9d,0x97,0xb6},
											{0x51,0x40,0x0f,0xb9,0x48,0x87,0x88,0x15,0x22,0xa0,0x74,0xb4,0x14,0xb7,0xf5,0x24},
											{0xa6,0xbd,0xc6,0xda,0x71,0xa9,0xef,0x84,0x65,0x2c,0xc2,0x35,0xee,0xaf,0x68,0xd7},
											{0xb8,0x43,0x2e,0x77,0x5f,0xce,0xf1,0xfa,0xd5,0x3f,0x9f,0x2a,0x49,0xbb,0x50,0x12},
											{0xa7,0xb5,0xa5,0xf7,0xe9,0x91,0x69,0xbc,0xd6,0x07,0xcd,0x28,0x4d,0x94,0xdf,0x4a},
											{0x83,0xd8,0x2d,0x6c,0x66,0x29,0x3c,0x86,0xd4,0xea,0x70,0xe0,0x18,0xe7,0xe2,0x47},
											{0xcb,0xf3,0x37,0xf4,0xcf,0xd2,0x17,0x41,0x6a,0xc8,0x45,0x64,0xc3,0xc5,0xd1,0xfb},
											{0xe6,0xff,0xd0,0x4b,0x46,0xb1,0x92,0x32,0x08,0x4e,0xad,0x52,0x23,0x7f,0x95,0xa3},
											{0xfc,0xe5,0x80,0xb3,0xe8,0xc4,0x19,0x3a,0x9b,0x00,0x75,0x61,0xa4,0x6e,0x89,0xfe}	};

#define subByteInv_g(b) (SBOX_INV_G[((b)>>4)&0xf][(b)&0xf])
											
uint128 shiftRowsInv(uint128 a);
uint128 mixColumnInv(uint128 a);
unsigned char *logDual_DEC(const unsigned char *str,const unsigned char *k);

uint128 shiftRowsInv(uint128 a)
{	
	uint128 t = 0,k;
	int i,j;
	unsigned int word;
	for(int i=0;i<4;i++)
	{
		word = Word(a,i);
		for(int j=0;j<4;j++)	
		{
			k = Byte(word,j);
			t|=putAt(k,(4+i+j)&3,j);
		}
	}
	return t;	
}
/*0e 0b 0d 09 transforms to ef 34 77 e3*/
uint128 mixColumnInv(uint128 a)
{
	unsigned int ti[4]={0xef3477e3,0xe3ef3477,0x77e3ef34,0x3477e3ef},word;
	uint128 u=0,k,t;
	for(int i=0;i<4;i++)
	{
		word = Word(a,i);
		for(int j=0;j<4;j++)	
		{	
			
			t=multVector(ti[j],word);
			u |= putAt(t,i,j);
		}
	}
	return u;	
}

unsigned char *logDual_DEC(const unsigned char *str,const unsigned char *k)
{	
	uint128 key = 0,t,*K,x = 0,y;
	unsigned int word;
	unsigned char *res = (unsigned char*)malloc(17);
	for(int i=0;i<4;i++)
		for(int j=0;j<4;j++)	
		{
			t = k[(i<<2)+j];
			key|=putAt(t,i,j);
			t = str[(i<<2)+j];
			x  |=putAt(t,i,j);
		}
	
	K = keyExpansion(key);
	x = xor_state(x,K[10]);
	x = shiftRowsInv(x);
	y=x;
	x=0;
	for(int i=0;i<4;i++)
	{
		word = Word(y,i);
		for(int j=0;j<4;j++)
		{
			t = subByteInv_g(Byte(word,j));
			x |= putAt(t,i,j);
		}
		
		
	}
	for(int r=1;r<10;r++)
	{
		x = xor_state(x,K[10-r]);
		x = mixColumnInv(x);
		x = shiftRowsInv(x);
		y=x;
		x=0;
		for(int i=0;i<4;i++)
		{
			word = Word(y,i);
			for(int j=0;j<4;j++)
			{
				t = subByteInv_g(Byte(word,j));
				x |= putAt(t,i,j);
			}
			
		}
		
	}
	x = xor_state(x,K[0]);
	for(int i=0;i<4;i++)
	{
		word = Word(x,i);
		for(int j=0;j<4;j++)
			res[(i<<2)+j] = (unsigned char)Byte(word,j);
	}
	res[16] = '\0';
	return res;
}

#endif















